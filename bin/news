#!/home/jp/.local/bin/newsvenv/bin/python

from functools import reduce
from reader import make_reader, FeedExistsError
import os
import os.path
import json
import bs4
from bs4 import BeautifulSoup, NavigableString
from enum import Enum
import requests
import textwrap
import time
import json
import sys
import math
import re
import subprocess
import curses
from curses import wrapper
from multiprocessing import Process, Queue

home_path = '/home/jp/.local/share/securities/'


class EntriesPager:

    def __init__(self, stdscr):
        self.reader = make_reader(home_path + 'db.sqlite')
        self.stdscr = stdscr
        self.search_query = ''
        self.refresh_entries()        

    def refresh_entries(self):
        if search_query:
            self.get_entries_from_search_query()        
        else:
            self.get_all_entries()

    def get_entries_from_search_query(self):
        queried_entries = self.reader.search_entries(search_query)
        self.entries = map(search_result_to_entry, list(queried_entries))
        
    def search_result_to_entry(result):
        return self.reader.get_entry(result.object_id)

    def get_all_entries(self):
        queried_entries = reader.get_entries()
        self.entries = list(queried_entries)

    def start(self):
        last_updated = time.time()
        while expression != 'quit':            
            self.display_entries()            
            if time.time() - last_updated > 60:
                self.refetch_entries()
                last_updated = time.time()

    def display_entries():
        # Keeping track of input character
        key = 0

        # Position tracking info
        first_entry = 0
        entries_per_chunk = 15
        current_selected = 0
        entries_drawn = 0
        previous_entries_drawn = 0
        previous_firsts = []
        direction = Direction.DOWN
        entries_on_display = []

        def next_page():
            nonlocal previous_firsts
            nonlocal first_entry
            nonlocal current_selected
            nonlocal entries_drawn
            if first_entry + entries_drawn < len(entries):
                previous_firsts.append(first_entry)
                first_entry += entries_drawn
                current_selected = 0
                entries_drawn = 0

        def next_item():
            nonlocal current_selected
            nonlocal direction
            current_selected += 1
            direction = Direction.DOWN

        def move_down_by_one():
            nonlocal first_entry
            nonlocal direction
            first_entry += 1
            direction = direction.DOWN

        def prev_item():
            nonlocal current_selected
            nonlocal direction
            current_selected -= 1
            direction = direction.UP

        def move_up_by_one():
            nonlocal first_entry
            nonlocal direction
            first_entry -= 1
            direction = Direction.UP

        def down_by_one():
            if current_selected < entries_drawn - 1:
                next_item()
            elif first_entry + entries_drawn < len(entries):
                move_down_by_one()

        def up_by_one():
            if current_selected > 0:
                prev_item()
            elif first_entry > 0:
                move_up_by_one()

        def prev_page():
            if len(previous_firsts) > 0:
                first_entry = previous_firsts.pop()

        while (key != ord('q')):

            # Check input
            if key == ord('k'):
                down_by_one()
            elif key == ord('l'):
                up_by_one()
            elif key == ord('f'):
                next_page()
            elif key == ord('b'):
                prev_page()
            elif key == ord('/'):  # Search
                expression = getInput(stdscr, "Search: ")
                return
            elif key == ord(':'):  # Search security
                expression = get_security_query(stdscr)
                return
            elif key == ord('v'):
                print_entry(stdscr, entries_on_display[current_selected])
            elif key == ord('m'):
                os.system('firefox ' + entries_on_display[current_selected].link)

            while True:

                # Initialize
                stdscr.clear()

                # Get entries
                entries_on_display = entries[first_entry:first_entry +
                                            entries_per_chunk]

                previous_entries_drawn = entries_drawn
                # Draw as many entries on screen as possible
                entries_drawn = print_entries(stdscr,
                                            entries_on_display,
                                            current_selected)

                if direction == Direction.DOWN:
                    if entries_drawn >= previous_entries_drawn:
                        break
                    first_entry += 1
                    current_selected = entries_drawn - 1
                else:
                    break

            if expression:
                rows, cols = stdscr.getmaxyx()
                total_found_message = str(len(entries)) + " results for: "

                if len(expression) > cols - len(total_found_message) - 4:
                    stdscr.addstr(rows - 1, 0, total_found_message +
                                expression[:cols - len(total_found_message) - 4] + "...")
                else:
                    stdscr.addstr(rows - 1, 0, total_found_message + expression)
            # Refresh the screen
            stdscr.refresh()

            stdscr.timeout(600)
            new_key = stdscr.getch()

            if new_key == -1:
                return
            else:
                key = new_key
                continue

        expression = 'quit'

    def refetch_entries(self):
        self.write_to_expression_line("Updating entries")
        reader.update_feeds()
        reader.update_search()                
        self.clear_expression_line()

    def write_to_expression_line(self, message):
        self.clear_expression_line()
        self.stdscr.addstr(message)
        self.stdscr.refresh()

    def clear_expression_line(self):
        lines, cols = stdscr.getmaxyx()
        self.stdscr.move(lines - 1, 0)
        self.stdscr.deleteln()
        self.stdscr.refresh()


def main(stdscr):
    setup_color(stdscr)

    entriesPage = EntriesPager(stdscr)
    entriesPage.start()


def printEntry(entry, index, window, selected):
    cy, cx = window.getyx()
    rows, cols = window.getmaxyx()
    total_lines_needed = 1

    title_attrs = curses.A_BOLD

    if selected:
        title_attrs += curses.color_pair(2)
    else:
        title_attrs += curses.color_pair(1)

    total_lines_needed += math.ceil(len(entry.title) / cols)

    summary = None
    if entry.summary:
        soup = BeautifulSoup(entry.summary, features="html.parser")
        wrapper = textwrap.TextWrapper(width=65)
        string = wrapper.fill(text=soup.get_text())
        summary = textwrap.indent(text=string, prefix='    ')

        total_lines_needed += math.ceil(len(summary[:300]) / cols)

    if cy + total_lines_needed > rows - 2:
        raise curses.error("Done")

    # Match for domain name in feed url
    feedname_regex = r"""https?://\w*\.(\w*\.\w*).*"""
    feedname_match = re.match(feedname_regex, entry.feed_url)

    if not feedname_match:
        feedname_match = ["nope", "can't do it"]

    window.addstr(entry.title + "\n", title_attrs)
    if entry.last_updated:
        window.addstr(
            "\t" + entry.last_updated.strftime("%B %d, %Y @ %H:%M") + " |- ")

    window.addstr(feedname_match[1] + "\n", curses.A_BOLD)
    if not summary:
        return

    window.addstr(summary[0:299] +
                  ('...' if len(summary) > 299 else '') + "\n")


def print_entries(stdscr, entries, current_selected):
    total_printed = 0
    for entry in entries:
        index = total_printed
        try:
            printEntry(entry, index, stdscr, (current_selected == index))
        except curses.error:
            break
        total_printed += 1
    return total_printed


class Direction(Enum):
    UP = 1
    DOWN = 2


def getInput(stdscr, message="in:"):
    rows, cols = stdscr.getmaxyx()
    stdscr.move(rows - 1, 0)
    stdscr.deleteln()
    stdscr.addstr(rows - 1, 0, message)
    curses.echo()
    user_input = stdscr.getstr()
    curses.noecho()
    return user_input.decode("utf-8")

def get_all_securities_keywords():
    securities_file = open(home_path + 'following.json')
    securities = json.load(securities_file)

    search_terms = reduce(lambda x, y: x + ' OR ' + y,
                          map(lambda security: reduce(lambda a, b: a + ' OR ' + b, security['queries']), securities))
    return search_terms


def add_or(current, next):
    return current + ' OR ' + next


def join_queries(queries):
    return reduce(add_or, queries)


def symbol_query(symbol):
    following_file = open(home_path + 'following.json')
    following = json.load(following_file)

    on_file = list(filter(
        lambda security: security['symbol'].lower() == symbol.lower(), following))

    if len(on_file) == 0:
        return 'Abadacadabra'

    return reduce(add_or, on_file[0]['queries'])


def get_security_query(stdscr):
    """Turn user input into list of security symbols to match search queries on"""
    clear_buffer(stdscr)
    stdscr.addstr(':')
    curses.echo()
    security = stdscr.getstr().decode('utf-8')
    query = None
    if security.lower() == "all":
        query = get_all_securities_keywords()
    else:
        user_symbols = re.split(' +', security)
        queries = map(symbol_query, user_symbols)
        query = reduce(add_or, queries)

    curses.noecho()
    return query



def get_ch(stdscr, ch):
    ch.put(stdscr.getch())


def print_entry(stdscr, entry):
    # Initialize
    stdscr.clear()
    # Refresh the screen
    stdscr.refresh()
    print_content(stdscr, entry.link)


def getClass(link):
    feeds_file = open(home_path + 'feeds.json')
    feeds = json.load(feeds_file)

    homeMatch = re.match(r"https?://.*\.(.*)\..*/.*", link)

    linkBase = homeMatch.group(1)

    for feed in feeds['feeds']:
        feedMatch = re.match(r"https?://.*\." + linkBase + "\..*/.*",
                             feed['htmlUrl'])
        if feedMatch:
            return feed['contentClass']

    return 'root'


def print_content(stdscr, link):

    # Attempt to fetch
    response = requests.get(link, headers={
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:90.0) Gecko/20100101 Firefox/90.0'
    })

    if not response.ok:
        stdscr.addstr("Unable to reach " + link)

    # Use Beautiful Soup to get the html page
    soup = BeautifulSoup(response.content,
                         features="html.parser")

    # Use the feeds class definition to locate content on page
    content = soup.find("div", class_=getClass(link))

    if content:
        children = content.children
        final_content = ''
        wrapper = textwrap.TextWrapper(width=65,
                                       replace_whitespace=False,
                                       drop_whitespace=False)
        for item in children:
            string = wrapper.fill(text=item if type(
                item) is bs4.element.NavigableString else item.get_text())
            final_content += textwrap.indent(text=string,
                                             prefix='    ') + "\n\n"
        subprocess.run(["w3m", "-no-mouse", "-o", "confirm_qq=FALSE"],
                       input=final_content.encode('utf-8'))
    else:
        subprocess.run(["w3m", "-no-mouse", "-o", "confirm_qq=FALSE"],
                       input=str(soup).encode('utf-8'))


def getAndUpdateFeeds():
    feeds_file = open(home_path + 'feeds.json')
    feeds = json.load(feeds_file)

    for feed in feeds['feeds']:
        try:
            reader.add_feed(feed['xmlUrl'])
            print("Added feed -| " + feed['title'])
        except FeedExistsError:
            pass

    reader.update_feeds()
    reader.update_search()


def setup_color(stdscr):
    # Get the color pairs ready
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_YELLOW, -1)
    curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_YELLOW)


if __name__ == '__main__':
    wrapper(main)
